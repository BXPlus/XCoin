// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: blockchain.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_blockchain_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_blockchain_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_blockchain_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_blockchain_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_blockchain_2eproto;
namespace xcoin {
namespace interchange {
class Block;
struct BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class Blockchain;
struct BlockchainDefaultTypeInternal;
extern BlockchainDefaultTypeInternal _Blockchain_default_instance_;
class DNSEntry;
struct DNSEntryDefaultTypeInternal;
extern DNSEntryDefaultTypeInternal _DNSEntry_default_instance_;
class DNSHandshake;
struct DNSHandshakeDefaultTypeInternal;
extern DNSHandshakeDefaultTypeInternal _DNSHandshake_default_instance_;
class GetHeaders;
struct GetHeadersDefaultTypeInternal;
extern GetHeadersDefaultTypeInternal _GetHeaders_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Headers;
struct HeadersDefaultTypeInternal;
extern HeadersDefaultTypeInternal _Headers_default_instance_;
class PingHandshake;
struct PingHandshakeDefaultTypeInternal;
extern PingHandshakeDefaultTypeInternal _PingHandshake_default_instance_;
class XNodeMessage;
struct XNodeMessageDefaultTypeInternal;
extern XNodeMessageDefaultTypeInternal _XNodeMessage_default_instance_;
}  // namespace interchange
}  // namespace xcoin
PROTOBUF_NAMESPACE_OPEN
template<> ::xcoin::interchange::Block* Arena::CreateMaybeMessage<::xcoin::interchange::Block>(Arena*);
template<> ::xcoin::interchange::Blockchain* Arena::CreateMaybeMessage<::xcoin::interchange::Blockchain>(Arena*);
template<> ::xcoin::interchange::DNSEntry* Arena::CreateMaybeMessage<::xcoin::interchange::DNSEntry>(Arena*);
template<> ::xcoin::interchange::DNSHandshake* Arena::CreateMaybeMessage<::xcoin::interchange::DNSHandshake>(Arena*);
template<> ::xcoin::interchange::GetHeaders* Arena::CreateMaybeMessage<::xcoin::interchange::GetHeaders>(Arena*);
template<> ::xcoin::interchange::Header* Arena::CreateMaybeMessage<::xcoin::interchange::Header>(Arena*);
template<> ::xcoin::interchange::Headers* Arena::CreateMaybeMessage<::xcoin::interchange::Headers>(Arena*);
template<> ::xcoin::interchange::PingHandshake* Arena::CreateMaybeMessage<::xcoin::interchange::PingHandshake>(Arena*);
template<> ::xcoin::interchange::XNodeMessage* Arena::CreateMaybeMessage<::xcoin::interchange::XNodeMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace xcoin {
namespace interchange {

// ===================================================================

class Block final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xcoin.interchange.Block) */ {
 public:
  inline Block() : Block(nullptr) {}
  ~Block() override;
  explicit constexpr Block(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block& default_instance() {
    return *internal_default_instance();
  }
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }
  inline void Swap(Block* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return new Block();
  }

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Block& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Block& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xcoin.interchange.Block";
  }
  protected:
  explicit Block(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 2,
    kPreviousHashFieldNumber = 3,
    kDataFieldNumber = 5,
    kMinterAddressFieldNumber = 9,
    kIndexFieldNumber = 1,
    kTimestampFieldNumber = 4,
    kDifficultyFieldNumber = 6,
    kNonceFieldNumber = 7,
    kMinterBalanceFieldNumber = 8,
  };
  // optional string hash = 2;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // optional string previousHash = 3;
  bool has_previoushash() const;
  private:
  bool _internal_has_previoushash() const;
  public:
  void clear_previoushash();
  const std::string& previoushash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_previoushash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_previoushash();
  PROTOBUF_MUST_USE_RESULT std::string* release_previoushash();
  void set_allocated_previoushash(std::string* previoushash);
  private:
  const std::string& _internal_previoushash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previoushash(const std::string& value);
  std::string* _internal_mutable_previoushash();
  public:

  // optional string data = 5;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional string minterAddress = 9;
  bool has_minteraddress() const;
  private:
  bool _internal_has_minteraddress() const;
  public:
  void clear_minteraddress();
  const std::string& minteraddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minteraddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minteraddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_minteraddress();
  void set_allocated_minteraddress(std::string* minteraddress);
  private:
  const std::string& _internal_minteraddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minteraddress(const std::string& value);
  std::string* _internal_mutable_minteraddress();
  public:

  // optional int64 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int64 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 difficulty = 6;
  bool has_difficulty() const;
  private:
  bool _internal_has_difficulty() const;
  public:
  void clear_difficulty();
  ::PROTOBUF_NAMESPACE_ID::int64 difficulty() const;
  void set_difficulty(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_difficulty() const;
  void _internal_set_difficulty(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 nonce = 7;
  bool has_nonce() const;
  private:
  bool _internal_has_nonce() const;
  public:
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::int64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 minterBalance = 8;
  bool has_minterbalance() const;
  private:
  bool _internal_has_minterbalance() const;
  public:
  void clear_minterbalance();
  ::PROTOBUF_NAMESPACE_ID::int64 minterbalance() const;
  void set_minterbalance(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_minterbalance() const;
  void _internal_set_minterbalance(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:xcoin.interchange.Block)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previoushash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minteraddress_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 difficulty_;
  ::PROTOBUF_NAMESPACE_ID::int64 nonce_;
  ::PROTOBUF_NAMESPACE_ID::int64 minterbalance_;
  friend struct ::TableStruct_blockchain_2eproto;
};
// -------------------------------------------------------------------

class Blockchain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xcoin.interchange.Blockchain) */ {
 public:
  inline Blockchain() : Blockchain(nullptr) {}
  ~Blockchain() override;
  explicit constexpr Blockchain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Blockchain(const Blockchain& from);
  Blockchain(Blockchain&& from) noexcept
    : Blockchain() {
    *this = ::std::move(from);
  }

  inline Blockchain& operator=(const Blockchain& from) {
    CopyFrom(from);
    return *this;
  }
  inline Blockchain& operator=(Blockchain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Blockchain& default_instance() {
    return *internal_default_instance();
  }
  static inline const Blockchain* internal_default_instance() {
    return reinterpret_cast<const Blockchain*>(
               &_Blockchain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Blockchain& a, Blockchain& b) {
    a.Swap(&b);
  }
  inline void Swap(Blockchain* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Blockchain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Blockchain* New() const final {
    return new Blockchain();
  }

  Blockchain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Blockchain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Blockchain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Blockchain& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Blockchain* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xcoin.interchange.Blockchain";
  }
  protected:
  explicit Blockchain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated .xcoin.interchange.Block blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::xcoin::interchange::Block* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::Block >*
      mutable_blocks();
  private:
  const ::xcoin::interchange::Block& _internal_blocks(int index) const;
  ::xcoin::interchange::Block* _internal_add_blocks();
  public:
  const ::xcoin::interchange::Block& blocks(int index) const;
  ::xcoin::interchange::Block* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::Block >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:xcoin.interchange.Blockchain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::Block > blocks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2eproto;
};
// -------------------------------------------------------------------

class GetHeaders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xcoin.interchange.GetHeaders) */ {
 public:
  inline GetHeaders() : GetHeaders(nullptr) {}
  ~GetHeaders() override;
  explicit constexpr GetHeaders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetHeaders(const GetHeaders& from);
  GetHeaders(GetHeaders&& from) noexcept
    : GetHeaders() {
    *this = ::std::move(from);
  }

  inline GetHeaders& operator=(const GetHeaders& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHeaders& operator=(GetHeaders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHeaders& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHeaders* internal_default_instance() {
    return reinterpret_cast<const GetHeaders*>(
               &_GetHeaders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetHeaders& a, GetHeaders& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHeaders* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHeaders* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetHeaders* New() const final {
    return new GetHeaders();
  }

  GetHeaders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetHeaders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetHeaders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetHeaders& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHeaders* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xcoin.interchange.GetHeaders";
  }
  protected:
  explicit GetHeaders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHeaderHashesFieldNumber = 4,
    kStopHashFieldNumber = 3,
    kVersionFieldNumber = 1,
    kHashCountFieldNumber = 2,
  };
  // repeated string blockHeaderHashes = 4;
  int blockheaderhashes_size() const;
  private:
  int _internal_blockheaderhashes_size() const;
  public:
  void clear_blockheaderhashes();
  const std::string& blockheaderhashes(int index) const;
  std::string* mutable_blockheaderhashes(int index);
  void set_blockheaderhashes(int index, const std::string& value);
  void set_blockheaderhashes(int index, std::string&& value);
  void set_blockheaderhashes(int index, const char* value);
  void set_blockheaderhashes(int index, const char* value, size_t size);
  std::string* add_blockheaderhashes();
  void add_blockheaderhashes(const std::string& value);
  void add_blockheaderhashes(std::string&& value);
  void add_blockheaderhashes(const char* value);
  void add_blockheaderhashes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blockheaderhashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blockheaderhashes();
  private:
  const std::string& _internal_blockheaderhashes(int index) const;
  std::string* _internal_add_blockheaderhashes();
  public:

  // string stopHash = 3;
  void clear_stophash();
  const std::string& stophash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stophash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stophash();
  PROTOBUF_MUST_USE_RESULT std::string* release_stophash();
  void set_allocated_stophash(std::string* stophash);
  private:
  const std::string& _internal_stophash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stophash(const std::string& value);
  std::string* _internal_mutable_stophash();
  public:

  // uint32 version = 1;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 hashCount = 2;
  void clear_hashcount();
  ::PROTOBUF_NAMESPACE_ID::uint32 hashcount() const;
  void set_hashcount(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hashcount() const;
  void _internal_set_hashcount(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:xcoin.interchange.GetHeaders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blockheaderhashes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stophash_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hashcount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2eproto;
};
// -------------------------------------------------------------------

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xcoin.interchange.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit constexpr Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return new Header();
  }

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Header& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xcoin.interchange.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreviousBlockHeaderHashFieldNumber = 1,
    kMerkleRootHashFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // string previousBlockHeaderHash = 1;
  void clear_previousblockheaderhash();
  const std::string& previousblockheaderhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_previousblockheaderhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_previousblockheaderhash();
  PROTOBUF_MUST_USE_RESULT std::string* release_previousblockheaderhash();
  void set_allocated_previousblockheaderhash(std::string* previousblockheaderhash);
  private:
  const std::string& _internal_previousblockheaderhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previousblockheaderhash(const std::string& value);
  std::string* _internal_mutable_previousblockheaderhash();
  public:

  // string merkleRootHash = 2;
  void clear_merkleroothash();
  const std::string& merkleroothash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_merkleroothash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_merkleroothash();
  PROTOBUF_MUST_USE_RESULT std::string* release_merkleroothash();
  void set_allocated_merkleroothash(std::string* merkleroothash);
  private:
  const std::string& _internal_merkleroothash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_merkleroothash(const std::string& value);
  std::string* _internal_mutable_merkleroothash();
  public:

  // uint32 time = 3;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:xcoin.interchange.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previousblockheaderhash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr merkleroothash_;
  ::PROTOBUF_NAMESPACE_ID::uint32 time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2eproto;
};
// -------------------------------------------------------------------

class Headers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xcoin.interchange.Headers) */ {
 public:
  inline Headers() : Headers(nullptr) {}
  ~Headers() override;
  explicit constexpr Headers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Headers(const Headers& from);
  Headers(Headers&& from) noexcept
    : Headers() {
    *this = ::std::move(from);
  }

  inline Headers& operator=(const Headers& from) {
    CopyFrom(from);
    return *this;
  }
  inline Headers& operator=(Headers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Headers& default_instance() {
    return *internal_default_instance();
  }
  static inline const Headers* internal_default_instance() {
    return reinterpret_cast<const Headers*>(
               &_Headers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Headers& a, Headers& b) {
    a.Swap(&b);
  }
  inline void Swap(Headers* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Headers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Headers* New() const final {
    return new Headers();
  }

  Headers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Headers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Headers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Headers& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Headers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xcoin.interchange.Headers";
  }
  protected:
  explicit Headers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 2,
    kCountFieldNumber = 1,
  };
  // repeated .xcoin.interchange.Header headers = 2;
  int headers_size() const;
  private:
  int _internal_headers_size() const;
  public:
  void clear_headers();
  ::xcoin::interchange::Header* mutable_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::Header >*
      mutable_headers();
  private:
  const ::xcoin::interchange::Header& _internal_headers(int index) const;
  ::xcoin::interchange::Header* _internal_add_headers();
  public:
  const ::xcoin::interchange::Header& headers(int index) const;
  ::xcoin::interchange::Header* add_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::Header >&
      headers() const;

  // uint32 count = 1;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:xcoin.interchange.Headers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::Header > headers_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2eproto;
};
// -------------------------------------------------------------------

class XNodeMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xcoin.interchange.XNodeMessage) */ {
 public:
  inline XNodeMessage() : XNodeMessage(nullptr) {}
  ~XNodeMessage() override;
  explicit constexpr XNodeMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XNodeMessage(const XNodeMessage& from);
  XNodeMessage(XNodeMessage&& from) noexcept
    : XNodeMessage() {
    *this = ::std::move(from);
  }

  inline XNodeMessage& operator=(const XNodeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline XNodeMessage& operator=(XNodeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XNodeMessage& default_instance() {
    return *internal_default_instance();
  }
  enum ContentsCase {
    kGetHeadersMessage = 5,
    kHeadersMessage = 6,
    kDnsHandshakeMessage = 7,
    CONTENTS_NOT_SET = 0,
  };

  static inline const XNodeMessage* internal_default_instance() {
    return reinterpret_cast<const XNodeMessage*>(
               &_XNodeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(XNodeMessage& a, XNodeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(XNodeMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XNodeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline XNodeMessage* New() const final {
    return new XNodeMessage();
  }

  XNodeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XNodeMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XNodeMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const XNodeMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XNodeMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xcoin.interchange.XNodeMessage";
  }
  protected:
  explicit XNodeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartStringFieldNumber = 1,
    kCommandFieldNumber = 2,
    kChecksumFieldNumber = 4,
    kSizeFieldNumber = 3,
    kGetHeadersMessageFieldNumber = 5,
    kHeadersMessageFieldNumber = 6,
    kDnsHandshakeMessageFieldNumber = 7,
  };
  // string startString = 1;
  void clear_startstring();
  const std::string& startstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_startstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_startstring();
  PROTOBUF_MUST_USE_RESULT std::string* release_startstring();
  void set_allocated_startstring(std::string* startstring);
  private:
  const std::string& _internal_startstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_startstring(const std::string& value);
  std::string* _internal_mutable_startstring();
  public:

  // string command = 2;
  void clear_command();
  const std::string& command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command();
  PROTOBUF_MUST_USE_RESULT std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // string checksum = 4;
  void clear_checksum();
  const std::string& checksum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_checksum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_checksum();
  PROTOBUF_MUST_USE_RESULT std::string* release_checksum();
  void set_allocated_checksum(std::string* checksum);
  private:
  const std::string& _internal_checksum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checksum(const std::string& value);
  std::string* _internal_mutable_checksum();
  public:

  // uint32 size = 3;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .xcoin.interchange.GetHeaders getHeadersMessage = 5;
  bool has_getheadersmessage() const;
  private:
  bool _internal_has_getheadersmessage() const;
  public:
  void clear_getheadersmessage();
  const ::xcoin::interchange::GetHeaders& getheadersmessage() const;
  PROTOBUF_MUST_USE_RESULT ::xcoin::interchange::GetHeaders* release_getheadersmessage();
  ::xcoin::interchange::GetHeaders* mutable_getheadersmessage();
  void set_allocated_getheadersmessage(::xcoin::interchange::GetHeaders* getheadersmessage);
  private:
  const ::xcoin::interchange::GetHeaders& _internal_getheadersmessage() const;
  ::xcoin::interchange::GetHeaders* _internal_mutable_getheadersmessage();
  public:
  void unsafe_arena_set_allocated_getheadersmessage(
      ::xcoin::interchange::GetHeaders* getheadersmessage);
  ::xcoin::interchange::GetHeaders* unsafe_arena_release_getheadersmessage();

  // .xcoin.interchange.Headers headersMessage = 6;
  bool has_headersmessage() const;
  private:
  bool _internal_has_headersmessage() const;
  public:
  void clear_headersmessage();
  const ::xcoin::interchange::Headers& headersmessage() const;
  PROTOBUF_MUST_USE_RESULT ::xcoin::interchange::Headers* release_headersmessage();
  ::xcoin::interchange::Headers* mutable_headersmessage();
  void set_allocated_headersmessage(::xcoin::interchange::Headers* headersmessage);
  private:
  const ::xcoin::interchange::Headers& _internal_headersmessage() const;
  ::xcoin::interchange::Headers* _internal_mutable_headersmessage();
  public:
  void unsafe_arena_set_allocated_headersmessage(
      ::xcoin::interchange::Headers* headersmessage);
  ::xcoin::interchange::Headers* unsafe_arena_release_headersmessage();

  // .xcoin.interchange.DNSHandshake dnsHandshakeMessage = 7;
  bool has_dnshandshakemessage() const;
  private:
  bool _internal_has_dnshandshakemessage() const;
  public:
  void clear_dnshandshakemessage();
  const ::xcoin::interchange::DNSHandshake& dnshandshakemessage() const;
  PROTOBUF_MUST_USE_RESULT ::xcoin::interchange::DNSHandshake* release_dnshandshakemessage();
  ::xcoin::interchange::DNSHandshake* mutable_dnshandshakemessage();
  void set_allocated_dnshandshakemessage(::xcoin::interchange::DNSHandshake* dnshandshakemessage);
  private:
  const ::xcoin::interchange::DNSHandshake& _internal_dnshandshakemessage() const;
  ::xcoin::interchange::DNSHandshake* _internal_mutable_dnshandshakemessage();
  public:
  void unsafe_arena_set_allocated_dnshandshakemessage(
      ::xcoin::interchange::DNSHandshake* dnshandshakemessage);
  ::xcoin::interchange::DNSHandshake* unsafe_arena_release_dnshandshakemessage();

  void clear_contents();
  ContentsCase contents_case() const;
  // @@protoc_insertion_point(class_scope:xcoin.interchange.XNodeMessage)
 private:
  class _Internal;
  void set_has_getheadersmessage();
  void set_has_headersmessage();
  void set_has_dnshandshakemessage();

  inline bool has_contents() const;
  inline void clear_has_contents();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr startstring_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checksum_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  union ContentsUnion {
    constexpr ContentsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::xcoin::interchange::GetHeaders* getheadersmessage_;
    ::xcoin::interchange::Headers* headersmessage_;
    ::xcoin::interchange::DNSHandshake* dnshandshakemessage_;
  } contents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_blockchain_2eproto;
};
// -------------------------------------------------------------------

class DNSEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xcoin.interchange.DNSEntry) */ {
 public:
  inline DNSEntry() : DNSEntry(nullptr) {}
  ~DNSEntry() override;
  explicit constexpr DNSEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DNSEntry(const DNSEntry& from);
  DNSEntry(DNSEntry&& from) noexcept
    : DNSEntry() {
    *this = ::std::move(from);
  }

  inline DNSEntry& operator=(const DNSEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DNSEntry& operator=(DNSEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DNSEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DNSEntry* internal_default_instance() {
    return reinterpret_cast<const DNSEntry*>(
               &_DNSEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DNSEntry& a, DNSEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DNSEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DNSEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DNSEntry* New() const final {
    return new DNSEntry();
  }

  DNSEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DNSEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DNSEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DNSEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DNSEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xcoin.interchange.DNSEntry";
  }
  protected:
  explicit DNSEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpportFieldNumber = 1,
    kPublicKeyFieldNumber = 2,
  };
  // string ipport = 1;
  void clear_ipport();
  const std::string& ipport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipport();
  PROTOBUF_MUST_USE_RESULT std::string* release_ipport();
  void set_allocated_ipport(std::string* ipport);
  private:
  const std::string& _internal_ipport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipport(const std::string& value);
  std::string* _internal_mutable_ipport();
  public:

  // string publicKey = 2;
  void clear_publickey();
  const std::string& publickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickey();
  PROTOBUF_MUST_USE_RESULT std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // @@protoc_insertion_point(class_scope:xcoin.interchange.DNSEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipport_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2eproto;
};
// -------------------------------------------------------------------

class PingHandshake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xcoin.interchange.PingHandshake) */ {
 public:
  inline PingHandshake() : PingHandshake(nullptr) {}
  ~PingHandshake() override;
  explicit constexpr PingHandshake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingHandshake(const PingHandshake& from);
  PingHandshake(PingHandshake&& from) noexcept
    : PingHandshake() {
    *this = ::std::move(from);
  }

  inline PingHandshake& operator=(const PingHandshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingHandshake& operator=(PingHandshake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingHandshake& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingHandshake* internal_default_instance() {
    return reinterpret_cast<const PingHandshake*>(
               &_PingHandshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PingHandshake& a, PingHandshake& b) {
    a.Swap(&b);
  }
  inline void Swap(PingHandshake* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingHandshake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingHandshake* New() const final {
    return new PingHandshake();
  }

  PingHandshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingHandshake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingHandshake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PingHandshake& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingHandshake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xcoin.interchange.PingHandshake";
  }
  protected:
  explicit PingHandshake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:xcoin.interchange.PingHandshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2eproto;
};
// -------------------------------------------------------------------

class DNSHandshake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xcoin.interchange.DNSHandshake) */ {
 public:
  inline DNSHandshake() : DNSHandshake(nullptr) {}
  ~DNSHandshake() override;
  explicit constexpr DNSHandshake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DNSHandshake(const DNSHandshake& from);
  DNSHandshake(DNSHandshake&& from) noexcept
    : DNSHandshake() {
    *this = ::std::move(from);
  }

  inline DNSHandshake& operator=(const DNSHandshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline DNSHandshake& operator=(DNSHandshake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DNSHandshake& default_instance() {
    return *internal_default_instance();
  }
  static inline const DNSHandshake* internal_default_instance() {
    return reinterpret_cast<const DNSHandshake*>(
               &_DNSHandshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DNSHandshake& a, DNSHandshake& b) {
    a.Swap(&b);
  }
  inline void Swap(DNSHandshake* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DNSHandshake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DNSHandshake* New() const final {
    return new DNSHandshake();
  }

  DNSHandshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DNSHandshake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DNSHandshake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DNSHandshake& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DNSHandshake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xcoin.interchange.DNSHandshake";
  }
  protected:
  explicit DNSHandshake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 2,
  };
  // repeated .xcoin.interchange.DNSEntry entries = 2;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::xcoin::interchange::DNSEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::DNSEntry >*
      mutable_entries();
  private:
  const ::xcoin::interchange::DNSEntry& _internal_entries(int index) const;
  ::xcoin::interchange::DNSEntry* _internal_add_entries();
  public:
  const ::xcoin::interchange::DNSEntry& entries(int index) const;
  ::xcoin::interchange::DNSEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::DNSEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:xcoin.interchange.DNSHandshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::DNSEntry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Block

// optional int64 index = 1;
inline bool Block::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Block::has_index() const {
  return _internal_has_index();
}
inline void Block::clear_index() {
  index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::index() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Block.index)
  return _internal_index();
}
inline void Block::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  index_ = value;
}
inline void Block::set_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.Block.index)
}

// optional string hash = 2;
inline bool Block::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Block::has_hash() const {
  return _internal_has_hash();
}
inline void Block::clear_hash() {
  hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Block::hash() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Block.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block::set_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.Block.hash)
}
inline std::string* Block::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.Block.hash)
  return _s;
}
inline const std::string& Block::_internal_hash() const {
  return hash_.Get();
}
inline void Block::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Block::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Block::release_hash() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.Block.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Block::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.Block.hash)
}

// optional string previousHash = 3;
inline bool Block::_internal_has_previoushash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Block::has_previoushash() const {
  return _internal_has_previoushash();
}
inline void Block::clear_previoushash() {
  previoushash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Block::previoushash() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Block.previousHash)
  return _internal_previoushash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block::set_previoushash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 previoushash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.Block.previousHash)
}
inline std::string* Block::mutable_previoushash() {
  std::string* _s = _internal_mutable_previoushash();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.Block.previousHash)
  return _s;
}
inline const std::string& Block::_internal_previoushash() const {
  return previoushash_.Get();
}
inline void Block::_internal_set_previoushash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  previoushash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Block::_internal_mutable_previoushash() {
  _has_bits_[0] |= 0x00000002u;
  return previoushash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Block::release_previoushash() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.Block.previousHash)
  if (!_internal_has_previoushash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return previoushash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Block::set_allocated_previoushash(std::string* previoushash) {
  if (previoushash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  previoushash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previoushash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.Block.previousHash)
}

// optional int64 timestamp = 4;
inline bool Block::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Block::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Block::clear_timestamp() {
  timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::timestamp() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Block.timestamp)
  return _internal_timestamp();
}
inline void Block::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  timestamp_ = value;
}
inline void Block::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.Block.timestamp)
}

// optional string data = 5;
inline bool Block::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Block::has_data() const {
  return _internal_has_data();
}
inline void Block::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Block::data() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Block.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.Block.data)
}
inline std::string* Block::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.Block.data)
  return _s;
}
inline const std::string& Block::_internal_data() const {
  return data_.Get();
}
inline void Block::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Block::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000004u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Block::release_data() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.Block.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Block::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.Block.data)
}

// optional int64 difficulty = 6;
inline bool Block::_internal_has_difficulty() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Block::has_difficulty() const {
  return _internal_has_difficulty();
}
inline void Block::clear_difficulty() {
  difficulty_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::_internal_difficulty() const {
  return difficulty_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::difficulty() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Block.difficulty)
  return _internal_difficulty();
}
inline void Block::_internal_set_difficulty(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  difficulty_ = value;
}
inline void Block::set_difficulty(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_difficulty(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.Block.difficulty)
}

// optional int64 nonce = 7;
inline bool Block::_internal_has_nonce() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Block::has_nonce() const {
  return _internal_has_nonce();
}
inline void Block::clear_nonce() {
  nonce_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::nonce() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Block.nonce)
  return _internal_nonce();
}
inline void Block::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  nonce_ = value;
}
inline void Block::set_nonce(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.Block.nonce)
}

// optional int64 minterBalance = 8;
inline bool Block::_internal_has_minterbalance() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Block::has_minterbalance() const {
  return _internal_has_minterbalance();
}
inline void Block::clear_minterbalance() {
  minterbalance_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::_internal_minterbalance() const {
  return minterbalance_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::minterbalance() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Block.minterBalance)
  return _internal_minterbalance();
}
inline void Block::_internal_set_minterbalance(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  minterbalance_ = value;
}
inline void Block::set_minterbalance(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_minterbalance(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.Block.minterBalance)
}

// optional string minterAddress = 9;
inline bool Block::_internal_has_minteraddress() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Block::has_minteraddress() const {
  return _internal_has_minteraddress();
}
inline void Block::clear_minteraddress() {
  minteraddress_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Block::minteraddress() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Block.minterAddress)
  return _internal_minteraddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block::set_minteraddress(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 minteraddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.Block.minterAddress)
}
inline std::string* Block::mutable_minteraddress() {
  std::string* _s = _internal_mutable_minteraddress();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.Block.minterAddress)
  return _s;
}
inline const std::string& Block::_internal_minteraddress() const {
  return minteraddress_.Get();
}
inline void Block::_internal_set_minteraddress(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  minteraddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Block::_internal_mutable_minteraddress() {
  _has_bits_[0] |= 0x00000008u;
  return minteraddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Block::release_minteraddress() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.Block.minterAddress)
  if (!_internal_has_minteraddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return minteraddress_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Block::set_allocated_minteraddress(std::string* minteraddress) {
  if (minteraddress != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  minteraddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), minteraddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.Block.minterAddress)
}

// -------------------------------------------------------------------

// Blockchain

// repeated .xcoin.interchange.Block blocks = 1;
inline int Blockchain::_internal_blocks_size() const {
  return blocks_.size();
}
inline int Blockchain::blocks_size() const {
  return _internal_blocks_size();
}
inline void Blockchain::clear_blocks() {
  blocks_.Clear();
}
inline ::xcoin::interchange::Block* Blockchain::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.Blockchain.blocks)
  return blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::Block >*
Blockchain::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:xcoin.interchange.Blockchain.blocks)
  return &blocks_;
}
inline const ::xcoin::interchange::Block& Blockchain::_internal_blocks(int index) const {
  return blocks_.Get(index);
}
inline const ::xcoin::interchange::Block& Blockchain::blocks(int index) const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Blockchain.blocks)
  return _internal_blocks(index);
}
inline ::xcoin::interchange::Block* Blockchain::_internal_add_blocks() {
  return blocks_.Add();
}
inline ::xcoin::interchange::Block* Blockchain::add_blocks() {
  ::xcoin::interchange::Block* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:xcoin.interchange.Blockchain.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::Block >&
Blockchain::blocks() const {
  // @@protoc_insertion_point(field_list:xcoin.interchange.Blockchain.blocks)
  return blocks_;
}

// -------------------------------------------------------------------

// GetHeaders

// uint32 version = 1;
inline void GetHeaders::clear_version() {
  version_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetHeaders::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetHeaders::version() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.GetHeaders.version)
  return _internal_version();
}
inline void GetHeaders::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  version_ = value;
}
inline void GetHeaders::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.GetHeaders.version)
}

// uint32 hashCount = 2;
inline void GetHeaders::clear_hashcount() {
  hashcount_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetHeaders::_internal_hashcount() const {
  return hashcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetHeaders::hashcount() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.GetHeaders.hashCount)
  return _internal_hashcount();
}
inline void GetHeaders::_internal_set_hashcount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  hashcount_ = value;
}
inline void GetHeaders::set_hashcount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hashcount(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.GetHeaders.hashCount)
}

// string stopHash = 3;
inline void GetHeaders::clear_stophash() {
  stophash_.ClearToEmpty();
}
inline const std::string& GetHeaders::stophash() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.GetHeaders.stopHash)
  return _internal_stophash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetHeaders::set_stophash(ArgT0&& arg0, ArgT... args) {
 
 stophash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.GetHeaders.stopHash)
}
inline std::string* GetHeaders::mutable_stophash() {
  std::string* _s = _internal_mutable_stophash();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.GetHeaders.stopHash)
  return _s;
}
inline const std::string& GetHeaders::_internal_stophash() const {
  return stophash_.Get();
}
inline void GetHeaders::_internal_set_stophash(const std::string& value) {
  
  stophash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetHeaders::_internal_mutable_stophash() {
  
  return stophash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetHeaders::release_stophash() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.GetHeaders.stopHash)
  return stophash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetHeaders::set_allocated_stophash(std::string* stophash) {
  if (stophash != nullptr) {
    
  } else {
    
  }
  stophash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stophash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.GetHeaders.stopHash)
}

// repeated string blockHeaderHashes = 4;
inline int GetHeaders::_internal_blockheaderhashes_size() const {
  return blockheaderhashes_.size();
}
inline int GetHeaders::blockheaderhashes_size() const {
  return _internal_blockheaderhashes_size();
}
inline void GetHeaders::clear_blockheaderhashes() {
  blockheaderhashes_.Clear();
}
inline std::string* GetHeaders::add_blockheaderhashes() {
  std::string* _s = _internal_add_blockheaderhashes();
  // @@protoc_insertion_point(field_add_mutable:xcoin.interchange.GetHeaders.blockHeaderHashes)
  return _s;
}
inline const std::string& GetHeaders::_internal_blockheaderhashes(int index) const {
  return blockheaderhashes_.Get(index);
}
inline const std::string& GetHeaders::blockheaderhashes(int index) const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.GetHeaders.blockHeaderHashes)
  return _internal_blockheaderhashes(index);
}
inline std::string* GetHeaders::mutable_blockheaderhashes(int index) {
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.GetHeaders.blockHeaderHashes)
  return blockheaderhashes_.Mutable(index);
}
inline void GetHeaders::set_blockheaderhashes(int index, const std::string& value) {
  blockheaderhashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.GetHeaders.blockHeaderHashes)
}
inline void GetHeaders::set_blockheaderhashes(int index, std::string&& value) {
  blockheaderhashes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xcoin.interchange.GetHeaders.blockHeaderHashes)
}
inline void GetHeaders::set_blockheaderhashes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blockheaderhashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xcoin.interchange.GetHeaders.blockHeaderHashes)
}
inline void GetHeaders::set_blockheaderhashes(int index, const char* value, size_t size) {
  blockheaderhashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xcoin.interchange.GetHeaders.blockHeaderHashes)
}
inline std::string* GetHeaders::_internal_add_blockheaderhashes() {
  return blockheaderhashes_.Add();
}
inline void GetHeaders::add_blockheaderhashes(const std::string& value) {
  blockheaderhashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:xcoin.interchange.GetHeaders.blockHeaderHashes)
}
inline void GetHeaders::add_blockheaderhashes(std::string&& value) {
  blockheaderhashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:xcoin.interchange.GetHeaders.blockHeaderHashes)
}
inline void GetHeaders::add_blockheaderhashes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blockheaderhashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xcoin.interchange.GetHeaders.blockHeaderHashes)
}
inline void GetHeaders::add_blockheaderhashes(const char* value, size_t size) {
  blockheaderhashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xcoin.interchange.GetHeaders.blockHeaderHashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetHeaders::blockheaderhashes() const {
  // @@protoc_insertion_point(field_list:xcoin.interchange.GetHeaders.blockHeaderHashes)
  return blockheaderhashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetHeaders::mutable_blockheaderhashes() {
  // @@protoc_insertion_point(field_mutable_list:xcoin.interchange.GetHeaders.blockHeaderHashes)
  return &blockheaderhashes_;
}

// -------------------------------------------------------------------

// Header

// string previousBlockHeaderHash = 1;
inline void Header::clear_previousblockheaderhash() {
  previousblockheaderhash_.ClearToEmpty();
}
inline const std::string& Header::previousblockheaderhash() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Header.previousBlockHeaderHash)
  return _internal_previousblockheaderhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_previousblockheaderhash(ArgT0&& arg0, ArgT... args) {
 
 previousblockheaderhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.Header.previousBlockHeaderHash)
}
inline std::string* Header::mutable_previousblockheaderhash() {
  std::string* _s = _internal_mutable_previousblockheaderhash();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.Header.previousBlockHeaderHash)
  return _s;
}
inline const std::string& Header::_internal_previousblockheaderhash() const {
  return previousblockheaderhash_.Get();
}
inline void Header::_internal_set_previousblockheaderhash(const std::string& value) {
  
  previousblockheaderhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_previousblockheaderhash() {
  
  return previousblockheaderhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Header::release_previousblockheaderhash() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.Header.previousBlockHeaderHash)
  return previousblockheaderhash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Header::set_allocated_previousblockheaderhash(std::string* previousblockheaderhash) {
  if (previousblockheaderhash != nullptr) {
    
  } else {
    
  }
  previousblockheaderhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previousblockheaderhash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.Header.previousBlockHeaderHash)
}

// string merkleRootHash = 2;
inline void Header::clear_merkleroothash() {
  merkleroothash_.ClearToEmpty();
}
inline const std::string& Header::merkleroothash() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Header.merkleRootHash)
  return _internal_merkleroothash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_merkleroothash(ArgT0&& arg0, ArgT... args) {
 
 merkleroothash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.Header.merkleRootHash)
}
inline std::string* Header::mutable_merkleroothash() {
  std::string* _s = _internal_mutable_merkleroothash();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.Header.merkleRootHash)
  return _s;
}
inline const std::string& Header::_internal_merkleroothash() const {
  return merkleroothash_.Get();
}
inline void Header::_internal_set_merkleroothash(const std::string& value) {
  
  merkleroothash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_merkleroothash() {
  
  return merkleroothash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Header::release_merkleroothash() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.Header.merkleRootHash)
  return merkleroothash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Header::set_allocated_merkleroothash(std::string* merkleroothash) {
  if (merkleroothash != nullptr) {
    
  } else {
    
  }
  merkleroothash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), merkleroothash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.Header.merkleRootHash)
}

// uint32 time = 3;
inline void Header::clear_time() {
  time_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::time() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Header.time)
  return _internal_time();
}
inline void Header::_internal_set_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  time_ = value;
}
inline void Header::set_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.Header.time)
}

// -------------------------------------------------------------------

// Headers

// uint32 count = 1;
inline void Headers::clear_count() {
  count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Headers::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Headers::count() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Headers.count)
  return _internal_count();
}
inline void Headers::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  count_ = value;
}
inline void Headers::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.Headers.count)
}

// repeated .xcoin.interchange.Header headers = 2;
inline int Headers::_internal_headers_size() const {
  return headers_.size();
}
inline int Headers::headers_size() const {
  return _internal_headers_size();
}
inline void Headers::clear_headers() {
  headers_.Clear();
}
inline ::xcoin::interchange::Header* Headers::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.Headers.headers)
  return headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::Header >*
Headers::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:xcoin.interchange.Headers.headers)
  return &headers_;
}
inline const ::xcoin::interchange::Header& Headers::_internal_headers(int index) const {
  return headers_.Get(index);
}
inline const ::xcoin::interchange::Header& Headers::headers(int index) const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.Headers.headers)
  return _internal_headers(index);
}
inline ::xcoin::interchange::Header* Headers::_internal_add_headers() {
  return headers_.Add();
}
inline ::xcoin::interchange::Header* Headers::add_headers() {
  ::xcoin::interchange::Header* _add = _internal_add_headers();
  // @@protoc_insertion_point(field_add:xcoin.interchange.Headers.headers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::Header >&
Headers::headers() const {
  // @@protoc_insertion_point(field_list:xcoin.interchange.Headers.headers)
  return headers_;
}

// -------------------------------------------------------------------

// XNodeMessage

// string startString = 1;
inline void XNodeMessage::clear_startstring() {
  startstring_.ClearToEmpty();
}
inline const std::string& XNodeMessage::startstring() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.XNodeMessage.startString)
  return _internal_startstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void XNodeMessage::set_startstring(ArgT0&& arg0, ArgT... args) {
 
 startstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.XNodeMessage.startString)
}
inline std::string* XNodeMessage::mutable_startstring() {
  std::string* _s = _internal_mutable_startstring();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.XNodeMessage.startString)
  return _s;
}
inline const std::string& XNodeMessage::_internal_startstring() const {
  return startstring_.Get();
}
inline void XNodeMessage::_internal_set_startstring(const std::string& value) {
  
  startstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* XNodeMessage::_internal_mutable_startstring() {
  
  return startstring_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* XNodeMessage::release_startstring() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.XNodeMessage.startString)
  return startstring_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void XNodeMessage::set_allocated_startstring(std::string* startstring) {
  if (startstring != nullptr) {
    
  } else {
    
  }
  startstring_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), startstring,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.XNodeMessage.startString)
}

// string command = 2;
inline void XNodeMessage::clear_command() {
  command_.ClearToEmpty();
}
inline const std::string& XNodeMessage::command() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.XNodeMessage.command)
  return _internal_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void XNodeMessage::set_command(ArgT0&& arg0, ArgT... args) {
 
 command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.XNodeMessage.command)
}
inline std::string* XNodeMessage::mutable_command() {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.XNodeMessage.command)
  return _s;
}
inline const std::string& XNodeMessage::_internal_command() const {
  return command_.Get();
}
inline void XNodeMessage::_internal_set_command(const std::string& value) {
  
  command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* XNodeMessage::_internal_mutable_command() {
  
  return command_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* XNodeMessage::release_command() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.XNodeMessage.command)
  return command_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void XNodeMessage::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  command_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), command,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.XNodeMessage.command)
}

// uint32 size = 3;
inline void XNodeMessage::clear_size() {
  size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 XNodeMessage::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 XNodeMessage::size() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.XNodeMessage.size)
  return _internal_size();
}
inline void XNodeMessage::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  size_ = value;
}
inline void XNodeMessage::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xcoin.interchange.XNodeMessage.size)
}

// string checksum = 4;
inline void XNodeMessage::clear_checksum() {
  checksum_.ClearToEmpty();
}
inline const std::string& XNodeMessage::checksum() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.XNodeMessage.checksum)
  return _internal_checksum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void XNodeMessage::set_checksum(ArgT0&& arg0, ArgT... args) {
 
 checksum_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.XNodeMessage.checksum)
}
inline std::string* XNodeMessage::mutable_checksum() {
  std::string* _s = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.XNodeMessage.checksum)
  return _s;
}
inline const std::string& XNodeMessage::_internal_checksum() const {
  return checksum_.Get();
}
inline void XNodeMessage::_internal_set_checksum(const std::string& value) {
  
  checksum_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* XNodeMessage::_internal_mutable_checksum() {
  
  return checksum_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* XNodeMessage::release_checksum() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.XNodeMessage.checksum)
  return checksum_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void XNodeMessage::set_allocated_checksum(std::string* checksum) {
  if (checksum != nullptr) {
    
  } else {
    
  }
  checksum_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), checksum,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.XNodeMessage.checksum)
}

// .xcoin.interchange.GetHeaders getHeadersMessage = 5;
inline bool XNodeMessage::_internal_has_getheadersmessage() const {
  return contents_case() == kGetHeadersMessage;
}
inline bool XNodeMessage::has_getheadersmessage() const {
  return _internal_has_getheadersmessage();
}
inline void XNodeMessage::set_has_getheadersmessage() {
  _oneof_case_[0] = kGetHeadersMessage;
}
inline void XNodeMessage::clear_getheadersmessage() {
  if (_internal_has_getheadersmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contents_.getheadersmessage_;
    }
    clear_has_contents();
  }
}
inline ::xcoin::interchange::GetHeaders* XNodeMessage::release_getheadersmessage() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.XNodeMessage.getHeadersMessage)
  if (_internal_has_getheadersmessage()) {
    clear_has_contents();
      ::xcoin::interchange::GetHeaders* temp = contents_.getheadersmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contents_.getheadersmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xcoin::interchange::GetHeaders& XNodeMessage::_internal_getheadersmessage() const {
  return _internal_has_getheadersmessage()
      ? *contents_.getheadersmessage_
      : reinterpret_cast< ::xcoin::interchange::GetHeaders&>(::xcoin::interchange::_GetHeaders_default_instance_);
}
inline const ::xcoin::interchange::GetHeaders& XNodeMessage::getheadersmessage() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.XNodeMessage.getHeadersMessage)
  return _internal_getheadersmessage();
}
inline ::xcoin::interchange::GetHeaders* XNodeMessage::unsafe_arena_release_getheadersmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xcoin.interchange.XNodeMessage.getHeadersMessage)
  if (_internal_has_getheadersmessage()) {
    clear_has_contents();
    ::xcoin::interchange::GetHeaders* temp = contents_.getheadersmessage_;
    contents_.getheadersmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XNodeMessage::unsafe_arena_set_allocated_getheadersmessage(::xcoin::interchange::GetHeaders* getheadersmessage) {
  clear_contents();
  if (getheadersmessage) {
    set_has_getheadersmessage();
    contents_.getheadersmessage_ = getheadersmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xcoin.interchange.XNodeMessage.getHeadersMessage)
}
inline ::xcoin::interchange::GetHeaders* XNodeMessage::_internal_mutable_getheadersmessage() {
  if (!_internal_has_getheadersmessage()) {
    clear_contents();
    set_has_getheadersmessage();
    contents_.getheadersmessage_ = CreateMaybeMessage< ::xcoin::interchange::GetHeaders >(GetArenaForAllocation());
  }
  return contents_.getheadersmessage_;
}
inline ::xcoin::interchange::GetHeaders* XNodeMessage::mutable_getheadersmessage() {
  ::xcoin::interchange::GetHeaders* _msg = _internal_mutable_getheadersmessage();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.XNodeMessage.getHeadersMessage)
  return _msg;
}

// .xcoin.interchange.Headers headersMessage = 6;
inline bool XNodeMessage::_internal_has_headersmessage() const {
  return contents_case() == kHeadersMessage;
}
inline bool XNodeMessage::has_headersmessage() const {
  return _internal_has_headersmessage();
}
inline void XNodeMessage::set_has_headersmessage() {
  _oneof_case_[0] = kHeadersMessage;
}
inline void XNodeMessage::clear_headersmessage() {
  if (_internal_has_headersmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contents_.headersmessage_;
    }
    clear_has_contents();
  }
}
inline ::xcoin::interchange::Headers* XNodeMessage::release_headersmessage() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.XNodeMessage.headersMessage)
  if (_internal_has_headersmessage()) {
    clear_has_contents();
      ::xcoin::interchange::Headers* temp = contents_.headersmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contents_.headersmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xcoin::interchange::Headers& XNodeMessage::_internal_headersmessage() const {
  return _internal_has_headersmessage()
      ? *contents_.headersmessage_
      : reinterpret_cast< ::xcoin::interchange::Headers&>(::xcoin::interchange::_Headers_default_instance_);
}
inline const ::xcoin::interchange::Headers& XNodeMessage::headersmessage() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.XNodeMessage.headersMessage)
  return _internal_headersmessage();
}
inline ::xcoin::interchange::Headers* XNodeMessage::unsafe_arena_release_headersmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xcoin.interchange.XNodeMessage.headersMessage)
  if (_internal_has_headersmessage()) {
    clear_has_contents();
    ::xcoin::interchange::Headers* temp = contents_.headersmessage_;
    contents_.headersmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XNodeMessage::unsafe_arena_set_allocated_headersmessage(::xcoin::interchange::Headers* headersmessage) {
  clear_contents();
  if (headersmessage) {
    set_has_headersmessage();
    contents_.headersmessage_ = headersmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xcoin.interchange.XNodeMessage.headersMessage)
}
inline ::xcoin::interchange::Headers* XNodeMessage::_internal_mutable_headersmessage() {
  if (!_internal_has_headersmessage()) {
    clear_contents();
    set_has_headersmessage();
    contents_.headersmessage_ = CreateMaybeMessage< ::xcoin::interchange::Headers >(GetArenaForAllocation());
  }
  return contents_.headersmessage_;
}
inline ::xcoin::interchange::Headers* XNodeMessage::mutable_headersmessage() {
  ::xcoin::interchange::Headers* _msg = _internal_mutable_headersmessage();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.XNodeMessage.headersMessage)
  return _msg;
}

// .xcoin.interchange.DNSHandshake dnsHandshakeMessage = 7;
inline bool XNodeMessage::_internal_has_dnshandshakemessage() const {
  return contents_case() == kDnsHandshakeMessage;
}
inline bool XNodeMessage::has_dnshandshakemessage() const {
  return _internal_has_dnshandshakemessage();
}
inline void XNodeMessage::set_has_dnshandshakemessage() {
  _oneof_case_[0] = kDnsHandshakeMessage;
}
inline void XNodeMessage::clear_dnshandshakemessage() {
  if (_internal_has_dnshandshakemessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contents_.dnshandshakemessage_;
    }
    clear_has_contents();
  }
}
inline ::xcoin::interchange::DNSHandshake* XNodeMessage::release_dnshandshakemessage() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.XNodeMessage.dnsHandshakeMessage)
  if (_internal_has_dnshandshakemessage()) {
    clear_has_contents();
      ::xcoin::interchange::DNSHandshake* temp = contents_.dnshandshakemessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contents_.dnshandshakemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xcoin::interchange::DNSHandshake& XNodeMessage::_internal_dnshandshakemessage() const {
  return _internal_has_dnshandshakemessage()
      ? *contents_.dnshandshakemessage_
      : reinterpret_cast< ::xcoin::interchange::DNSHandshake&>(::xcoin::interchange::_DNSHandshake_default_instance_);
}
inline const ::xcoin::interchange::DNSHandshake& XNodeMessage::dnshandshakemessage() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.XNodeMessage.dnsHandshakeMessage)
  return _internal_dnshandshakemessage();
}
inline ::xcoin::interchange::DNSHandshake* XNodeMessage::unsafe_arena_release_dnshandshakemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xcoin.interchange.XNodeMessage.dnsHandshakeMessage)
  if (_internal_has_dnshandshakemessage()) {
    clear_has_contents();
    ::xcoin::interchange::DNSHandshake* temp = contents_.dnshandshakemessage_;
    contents_.dnshandshakemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XNodeMessage::unsafe_arena_set_allocated_dnshandshakemessage(::xcoin::interchange::DNSHandshake* dnshandshakemessage) {
  clear_contents();
  if (dnshandshakemessage) {
    set_has_dnshandshakemessage();
    contents_.dnshandshakemessage_ = dnshandshakemessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xcoin.interchange.XNodeMessage.dnsHandshakeMessage)
}
inline ::xcoin::interchange::DNSHandshake* XNodeMessage::_internal_mutable_dnshandshakemessage() {
  if (!_internal_has_dnshandshakemessage()) {
    clear_contents();
    set_has_dnshandshakemessage();
    contents_.dnshandshakemessage_ = CreateMaybeMessage< ::xcoin::interchange::DNSHandshake >(GetArenaForAllocation());
  }
  return contents_.dnshandshakemessage_;
}
inline ::xcoin::interchange::DNSHandshake* XNodeMessage::mutable_dnshandshakemessage() {
  ::xcoin::interchange::DNSHandshake* _msg = _internal_mutable_dnshandshakemessage();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.XNodeMessage.dnsHandshakeMessage)
  return _msg;
}

inline bool XNodeMessage::has_contents() const {
  return contents_case() != CONTENTS_NOT_SET;
}
inline void XNodeMessage::clear_has_contents() {
  _oneof_case_[0] = CONTENTS_NOT_SET;
}
inline XNodeMessage::ContentsCase XNodeMessage::contents_case() const {
  return XNodeMessage::ContentsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DNSEntry

// string ipport = 1;
inline void DNSEntry::clear_ipport() {
  ipport_.ClearToEmpty();
}
inline const std::string& DNSEntry::ipport() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.DNSEntry.ipport)
  return _internal_ipport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DNSEntry::set_ipport(ArgT0&& arg0, ArgT... args) {
 
 ipport_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.DNSEntry.ipport)
}
inline std::string* DNSEntry::mutable_ipport() {
  std::string* _s = _internal_mutable_ipport();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.DNSEntry.ipport)
  return _s;
}
inline const std::string& DNSEntry::_internal_ipport() const {
  return ipport_.Get();
}
inline void DNSEntry::_internal_set_ipport(const std::string& value) {
  
  ipport_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DNSEntry::_internal_mutable_ipport() {
  
  return ipport_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DNSEntry::release_ipport() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.DNSEntry.ipport)
  return ipport_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DNSEntry::set_allocated_ipport(std::string* ipport) {
  if (ipport != nullptr) {
    
  } else {
    
  }
  ipport_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipport,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.DNSEntry.ipport)
}

// string publicKey = 2;
inline void DNSEntry::clear_publickey() {
  publickey_.ClearToEmpty();
}
inline const std::string& DNSEntry::publickey() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.DNSEntry.publicKey)
  return _internal_publickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DNSEntry::set_publickey(ArgT0&& arg0, ArgT... args) {
 
 publickey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.DNSEntry.publicKey)
}
inline std::string* DNSEntry::mutable_publickey() {
  std::string* _s = _internal_mutable_publickey();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.DNSEntry.publicKey)
  return _s;
}
inline const std::string& DNSEntry::_internal_publickey() const {
  return publickey_.Get();
}
inline void DNSEntry::_internal_set_publickey(const std::string& value) {
  
  publickey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DNSEntry::_internal_mutable_publickey() {
  
  return publickey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DNSEntry::release_publickey() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.DNSEntry.publicKey)
  return publickey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DNSEntry::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    
  } else {
    
  }
  publickey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publickey,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.DNSEntry.publicKey)
}

// -------------------------------------------------------------------

// PingHandshake

// string data = 1;
inline void PingHandshake::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& PingHandshake::data() const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.PingHandshake.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PingHandshake::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xcoin.interchange.PingHandshake.data)
}
inline std::string* PingHandshake::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.PingHandshake.data)
  return _s;
}
inline const std::string& PingHandshake::_internal_data() const {
  return data_.Get();
}
inline void PingHandshake::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PingHandshake::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PingHandshake::release_data() {
  // @@protoc_insertion_point(field_release:xcoin.interchange.PingHandshake.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PingHandshake::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:xcoin.interchange.PingHandshake.data)
}

// -------------------------------------------------------------------

// DNSHandshake

// repeated .xcoin.interchange.DNSEntry entries = 2;
inline int DNSHandshake::_internal_entries_size() const {
  return entries_.size();
}
inline int DNSHandshake::entries_size() const {
  return _internal_entries_size();
}
inline void DNSHandshake::clear_entries() {
  entries_.Clear();
}
inline ::xcoin::interchange::DNSEntry* DNSHandshake::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:xcoin.interchange.DNSHandshake.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::DNSEntry >*
DNSHandshake::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:xcoin.interchange.DNSHandshake.entries)
  return &entries_;
}
inline const ::xcoin::interchange::DNSEntry& DNSHandshake::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::xcoin::interchange::DNSEntry& DNSHandshake::entries(int index) const {
  // @@protoc_insertion_point(field_get:xcoin.interchange.DNSHandshake.entries)
  return _internal_entries(index);
}
inline ::xcoin::interchange::DNSEntry* DNSHandshake::_internal_add_entries() {
  return entries_.Add();
}
inline ::xcoin::interchange::DNSEntry* DNSHandshake::add_entries() {
  ::xcoin::interchange::DNSEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:xcoin.interchange.DNSHandshake.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xcoin::interchange::DNSEntry >&
DNSHandshake::entries() const {
  // @@protoc_insertion_point(field_list:xcoin.interchange.DNSHandshake.entries)
  return entries_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace interchange
}  // namespace xcoin

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_blockchain_2eproto
